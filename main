import os
import json
import gspread
from google.oauth2.service_account import Credentials
from datetime import datetime
from telegram import Update, Bot
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes

# ==========================
# НАСТРОЙКИ
# ==========================
TOKEN = os.environ.get("TELEGRAM_ADMIN_BOT_TOKEN")
SHOP_BOT_TOKEN = os.environ.get("TELEGRAM_SHOP_BOT_TOKEN")
ADMIN_PASSWORD = os.environ.get("ADMIN_PASSWORD")

# ==========================
# ПОДКЛЮЧЕНИЕ К GOOGLE SHEETS
# ==========================
def get_sheet():
    creds_json_str = os.environ.get("GCP_SERVICE_ACCOUNT_CREDENTIALS")
    if not creds_json_str:
        raise ValueError("GCP_SERVICE_ACCOUNT_CREDENTIALS environment variable not set.")
    
    try:
        creds_json = json.loads(creds_json_str)
    except json.JSONDecodeError:
        raise ValueError("Ошибка декодирования JSON из переменной окружения. Проверьте формат.")

    scopes = ["https://www.googleapis.com/auth/spreadsheets",
              "https://www.googleapis.com/auth/drive"]
    creds = Credentials.from_service_account_info(creds_json, scopes=scopes)
    client = gspread.authorize(creds)
    sheet = client.open("Orders").sheet1
    return sheet

# ==========================
# ФУНКЦИИ РАБОТЫ С ЗАКАЗАМИ
# ==========================
def create_order(client_id, status="waiting_req"):
    sheet = get_sheet()
    sheet.append_row([str(client_id), status, datetime.now().strftime("%Y-%m-%d %H:%M:%S")])
    print(f"Создан заказ для {client_id} со статусом {status}")

def update_order(client_id, new_status):
    sheet = get_sheet()
    client_id_str = str(client_id)
    
    try:
        # Находим ячейку с нужным client_id в первой колонке (col 1)
        cell = sheet.find(client_id_str, in_column=1)
        
        if cell:
            row_index = cell.row
            
            # Обновляем статус во второй колонке (col 2)
            sheet.update_cell(row_index, 2, new_status)
            
            # Обновляем время в третьей колонке (col 3)
            sheet.update_cell(row_index, 3, datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
            
            print(f"Обновлено для {client_id}: статус {new_status}")
            return True
        else:
            print(f"Не найден client_id {client_id} в таблице")
            return False
            
    except gspread.exceptions.CellNotFound:
        print(f"Не найден client_id {client_id} в таблице")
        return False
    except Exception as e:
        print(f"Произошла ошибка при обновлении: {e}")
        return False

def get_order_status(client_id):
    sheet = get_sheet()
    records = sheet.get_all_records()
    client_id_str = str(client_id)

    if not records:
        return None

    headers = list(records[0].keys())
    col_client_id = headers[0]
    col_status = headers[1]

    for row in records:
        if str(row[col_client_id]) == client_id_str:
            return row[col_status]
    return None

# ==========================
# ХРАНИЛИЩЕ ДЛЯ АДМИНОВ
# ==========================
verified_admins = set()
pending_file = {}

# ==========================
# ОБРАБОТЧИКИ КОМАНД
# ==========================
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.message.from_user.id
    if chat_id in verified_admins:
        await update.message.reply_text(
            "Привет, админ! Команды:\n"
            "/send_req <client_id> <реквизиты>\n"
            "/confirm <client_id>\n"
            "/myid\n"
            "/reset\n"
            "/check_order <client_id>"
        )
    else:
        await update.message.reply_text("Введи пароль для доступа к боту:")

async def handle_password(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.message.from_user.id
    if chat_id not in verified_admins:
        password = update.message.text.strip()
        if password == ADMIN_PASSWORD:
            verified_admins.add(chat_id)
            await update.message.reply_text("Пароль верный! Добро пожаловать, админ!")
        else:
            await update.message.reply_text("Неверный пароль! Попробуй ещё раз.")

async def myid(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(f"Твой chat_id: {update.message.from_user.id}")

# ==========================
# ОТПРАВКА РЕКВИЗИТОВ КЛИЕНТУ
# ==========================
async def send_req(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.message.from_user.id
    if chat_id not in verified_admins:
        await update.message.reply_text("Сначала введи пароль!")
        return
    
    args = context.args
    if len(args) < 2:
        await update.message.reply_text("Использование: /send_req <client_id> <реквизиты>")
        return
    
    try:
        client_id = int(args[0])
        requisites = " ".join(args[1:])
        
        status = get_order_status(client_id)
        if not status:
            create_order(client_id, "waiting_req")
        
        shop_bot = Bot(token=SHOP_BOT_TOKEN)
        await shop_bot.send_message(
            chat_id=client_id,
            text=f"Реквизиты для оплаты:\n{requisites}\n\nПосле оплаты обязательно отправь квитанцию!"
        )

        # Обновляем статус и время
        updated = update_order(client_id, "waiting_payment")
        if updated:
            await update.message.reply_text(f"Реквизиты отправлены клиенту {client_id}.")
        else:
            await update.message.reply_text(f"Не удалось обновить статус для {client_id}.")
    except Exception as e:
        await update.message.reply_text(f"Ошибка отправки реквизитов: {e}")

# ==========================
# ПОДТВЕРЖДЕНИЕ ОТПРАВКИ ТОВАРА
# ==========================
async def confirm(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.message.from_user.id
    if chat_id not in verified_admins:
        await update.message.reply_text("Сначала введи пароль!")
        return
    
    args = context.args
    if not args:
        await update.message.reply_text("Использование: /confirm <client_id>")
        return
    
    client_id = int(args[0])
    status = get_order_status(client_id)
    if status != "waiting_confirm":
        await update.message.reply_text("Нет заказа в статусе ожидания подтверждения!")
        return
    
    pending_file[chat_id] = client_id
    await update.message.reply_text("Теперь отправь файл или фото товара для клиента.")

async def reset(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.message.from_user.id
    if chat_id in verified_admins:
        verified_admins.remove(chat_id)
    await update.message.reply_text("Верификация сброшена. Введи пароль заново.")

async def check_order(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.message.from_user.id
    if chat_id not in verified_admins:
        await update.message.reply_text("Сначала введи пароль!")
        return
    
    args = context.args
    if not args:
        await update.message.reply_text("Использование: /check_order <client_id>")
        return
    
    client_id = int(args[0])
    status = get_order_status(client_id)
    if status:
        await update.message.reply_text(f"Статус заказа {client_id}: {status}")
    else:
        await update.message.reply_text("Заказ не найден.")

async def handle_product_file(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.message.from_user.id
    if chat_id not in verified_admins:
        await update.message.reply_text("Сначала введи пароль!")
        return
    
    if chat_id not in pending_file:
        await update.message.reply_text("Сначала выполни /confirm <client_id>.")
        return
    
    client_id = pending_file[chat_id]
    try:
        shop_bot = Bot(token=SHOP_BOT_TOKEN)
        if update.message.photo:
            photo = update.message.photo[-1].file_id
            await shop_bot.send_photo(chat_id=client_id, photo=photo, caption="Покупку подтверждено! Вот ваш товар. Спасибо!")
        elif update.message.document:
            document = update.message.document.file_id
            await shop_bot.send_document(chat_id=client_id, document=document, caption="Покупку подтверждено! Вот ваш товар. Спасибо!")
        else:
            await update.message.reply_text("Отправь файл или фото товара!")
            return
        
        updated = update_order(client_id, "done")
        if updated:
            await update.message.reply_text(f"Товар отправлен клиенту {client_id}.")
        else:
            await update.message.reply_text(f"Не удалось обновить статус для {client_id}.")
        del pending_file[chat_id]
    except Exception as e:
        await update.message.reply_text(f"Ошибка отправки товара: {e}")

# ==========================
# ЗАПУСК БОТА
# ==========================
def main():
    application = Application.builder().token(TOKEN).build()
    
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("myid", myid))
    application.add_handler(CommandHandler("send_req", send_req))
    application.add_handler(CommandHandler("confirm", confirm))
    application.add_handler(CommandHandler("reset", reset))
    application.add_handler(CommandHandler("check_order", check_order))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_password))
    application.add_handler(MessageHandler(filters.PHOTO | filters.Document.ALL, handle_product_file))
    
    print("Технический бот запущен...")
    application.run_polling()

if __name__ == "__main__":
    main()
