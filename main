import gspread
from oauth2client.service_account import ServiceAccountCredentials
from datetime import datetime
from telegram import Update, Bot
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes

# ==========================
# НАСТРОЙКИ
# ==========================
TOKEN = "7780990328:AAHozWNig4dY56eK15W2pU0ekR6sxpwEMcM"   # технический бот
SHOP_BOT_TOKEN = "8294869186:AAFXW4_oPojtESNjFrXxy3HILafSj-DZsYA"  # основной бот
ADMIN_PASSWORD = "10126522009"

# ==========================
# ПОДКЛЮЧЕНИЕ К GOOGLE SHEETS
# ==========================
def get_sheet():
    scope = ["https://spreadsheets.google.com/feeds", "https://www.googleapis.com/auth/drive"]
    creds = ServiceAccountCredentials.from_json_keyfile_name("credentials.json", scope)
    client = gspread.authorize(creds)
    sheet = client.open("Orders").sheet1   # твоя таблица Orders
    return sheet

# ==========================
# ФУНКЦИИ РАБОТЫ С ЗАКАЗАМИ
# ==========================
def create_order(client_id, status="waiting_req"):
    sheet = get_sheet()
    sheet.append_row([str(client_id), status, datetime.now().strftime("%Y-%m-%d %H:%M:%S")])

def update_order(client_id, new_status):
    sheet = get_sheet()
    records = sheet.get_all_records()
    for i, row in enumerate(records, start=2):  # строка 2 и дальше (1 = заголовки)
        if str(row["client_id"]) == str(client_id):
            sheet.update_cell(i, 2, new_status)  # колонка 2 = status
            return True
    return False

def get_order_status(client_id):
    sheet = get_sheet()
    records = sheet.get_all_records()
    for row in records:
        if str(row["client_id"]) == str(client_id):
            return row["status"]
    return None

# ==========================
# ХРАНИЛИЩЕ ДЛЯ АДМИНОВ
# ==========================
verified_admins = set()
pending_file = {}

# ==========================
# ОБРАБОТЧИКИ КОМАНД
# ==========================
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.message.from_user.id
    if chat_id in verified_admins:
        await update.message.reply_text("Привет, админ! Команды:\n/send_req <client_id> <реквизиты>\n/confirm <client_id>\n/myid\n/reset\n/check_order <client_id>")
    else:
        await update.message.reply_text("Введи пароль для доступа к боту:")

async def handle_password(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.message.from_user.id
    if chat_id not in verified_admins:
        password = update.message.text.strip()
        if password == ADMIN_PASSWORD:
            verified_admins.add(chat_id)
            await update.message.reply_text("Пароль верный! Добро пожаловать, админ!")
        else:
            await update.message.reply_text("Неверный пароль! Попробуй ещё раз.")

async def myid(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(f"Твой chat_id: {update.message.from_user.id}")

async def send_req(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.message.from_user.id
    if chat_id not in verified_admins:
        await update.message.reply_text("Сначала введи пароль!")
        return
    
    args = context.args
    if len(args) < 2:
        await update.message.reply_text("Использование: /send_req <client_id> <реквизиты>")
        return
    
    try:
        client_id = int(args[0])
        requisites = " ".join(args[1:])
        
        status = get_order_status(client_id)
        if not status:
            create_order(client_id, "waiting_req")
        
        shop_bot = Bot(token=SHOP_BOT_TOKEN)
        await shop_bot.send_message(
            chat_id=client_id,
            text=f"Реквизиты для оплаты:\n{requisites}\n\nПосле оплаты обязательно отправь квитанцию!"
        )
        update_order(client_id, "waiting_payment")
        await update.message.reply_text(f"Реквизиты отправлены клиенту {client_id}.")
    except Exception as e:
        await update.message.reply_text(f"Ошибка отправки реквизитов: {e}")

async def confirm(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.message.from_user.id
    if chat_id not in verified_admins:
        await update.message.reply_text("Сначала введи пароль!")
        return
    
    args = context.args
    if not args:
        await update.message.reply_text("Использование: /confirm <client_id>")
        return
    
    client_id = int(args[0])
    status = get_order_status(client_id)
    if status != "waiting_confirm":
        await update.message.reply_text("Нет заказа в статусе ожидания подтверждения!")
        return
    
    pending_file[chat_id] = client_id
    await update.message.reply_text("Теперь отправь файл или фото товара для клиента.")

async def reset(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.message.from_user.id
    if chat_id in verified_admins:
        verified_admins.remove(chat_id)
    await update.message.reply_text("Верификация сброшена. Введи пароль заново.")

async def check_order(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.message.from_user.id
    if chat_id not in verified_admins:
        await update.message.reply_text("Сначала введи пароль!")
        return
    
    args = context.args
    if not args:
        await update.message.reply_text("Использование: /check_order <client_id>")
        return
    
    client_id = int(args[0])
    status = get_order_status(client_id)
    if status:
        await update.message.reply_text(f"Статус заказа {client_id}: {status}")
    else:
        await update.message.reply_text("Заказ не найден.")

async def handle_product_file(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.message.from_user.id
    if chat_id not in verified_admins:
        await update.message.reply_text("Сначала введи пароль!")
        return
    
    if chat_id not in pending_file:
        await update.message.reply_text("Сначала выполни /confirm <client_id>.")
        return
    
    client_id = pending_file[chat_id]
    try:
        shop_bot = Bot(token=SHOP_BOT_TOKEN)
        if update.message.photo:
            photo = update.message.photo[-1].file_id
            await shop_bot.send_photo(chat_id=client_id, photo=photo, caption="Покупку подтверждено! Вот ваш товар. Спасибо!")
        elif update.message.document:
            document = update.message.document.file_id
            await shop_bot.send_document(chat_id=client_id, document=document, caption="Покупку подтверждено! Вот ваш товар. Спасибо!")
        else:
            await update.message.reply_text("Отправь файл или фото товара!")
            return
        
        update_order(client_id, "done")
        await update.message.reply_text(f"Товар отправлен клиенту {client_id}.")
        del pending_file[chat_id]
    except Exception as e:
        await update.message.reply_text(f"Ошибка отправки товара: {e}")

# ==========================
# ЗАПУСК БОТА
# ==========================
def main():
    application = Application.builder().token(TOKEN).build()
    
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("myid", myid))
    application.add_handler(CommandHandler("send_req", send_req))
    application.add_handler(CommandHandler("confirm", confirm))
    application.add_handler(CommandHandler("reset", reset))
    application.add_handler(CommandHandler("check_order", check_order))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_password))
    application.add_handler(MessageHandler(filters.PHOTO | filters.Document.ALL, handle_product_file))
    
    print("Технический бот запущен...")
    application.run_polling()

if __name__ == "__main__":
    main()
